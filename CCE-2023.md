# babykernel

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/27f1f29a-9f67-4ba8-bc89-531640ade8e7/Untitled.png)

unzip 명령어를 통해 zip파일을 압축해제 했다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/29b747d2-e867-41bb-ab21-e12d75a19822/Untitled.png)

.gz 파일도 압축 해제 해본다.

[ㄹㄹ](https://www.notion.so/6327464bcc6848bba1a303e9d04b8b5d?pvs=21)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e3f08f54-70ec-41c7-80e6-fef9c86c61a2/Untitled.png)

rootfs.img 파일이 뭐지 모르겠어서 file명령어를 이용해봤다. 잘은 모르겠지만 cpio로 압축된 파일 같아 보인다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bb47df64-ddaa-467f-914f-97e89c1307cf/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2eddd324-a30e-4b7c-8fb8-29a4d991cd21/Untitled.png)

그래서 cpio명령어를 통해서 압축을 푸는 명령어를 시도해봤다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/45ca9e33-0ff6-4da1-991f-21c73901f465/Untitled.png)

풀렸다

init 는 리눅스 커널 부팅이 완료된 뒤 실행되는 첫 번째 프로세스. 프로세스와 시스템의 초기화와 관리를 수행함.

실행 파일은 어디에 있는 걸까요??

**<local_run.sh>**

the shell script that contains qemu run command, we can change the qemu and Linux boot configuration here.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7435648a-0d02-4e7a-b15c-d3b9dfd8002e/Untitled.png)

1. `-cpu kvm64,+smep` 옵션을 보면 활성화된 smep을 사용하고 있다. smep은 프로세스가 커널 모드에서 실행될 때 유저 모드의 코드 실행을 제한하여 공격자가 특정 종류의 공격을 어렵게 만드는 보호 기법이다. (스택 실행을 불가능하게 만드는 nx 비트를 설정하는 것과 동일한 원리)
2. `-append "console=ttyS0 kaslr kpti=1 quiet panic=1"` 옵션에서 `kaslr`  파라미터를 지정하여 kaslr를 활성화 하고 있다. KASLR(kernel address space layout randomization)는 커널의 주소 공을 랜덤하게 배치함으로써 공격자가 커널 주소를 예측하는 것을 어렵게 만드는 보호 기법이다. (ASLR이랑 비슷)
3.  `-append "console=ttyS0 kaslr kpti=1 quiet panic=1"` 옵션에서 `kpti=1` 파라미터를 사용하여 KPTI를 활성화하고 있다. KPTI(kernel page table Isolation)은 커널의 페이지 테이블을 격리시켜 공격자가 메모리 정보를 누출하거나 변경하는 것을 방지하는 보호 기법이다.
4. `-append "console=ttyS0 kaslr kpti=1 quiet panic=1"` 옵션에서 `panic=1` 파라미터를 사용하여 커널이 문제가 발생했을 때 자동으로 패닉 상태로 전환되도록 설정하고 있다. 이것은 시스템의 보안을 강화하고 문제 발생 시 빠른 대응을 위한 조치를 취하는 데 도움이 된다. 

약 : kaslr, kpti,smep이 걸려있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/81104cd7-e97d-4d9e-9830-50811c7190f2/cb177e9c-83a9-4bbf-bfbd-95d6ad92251d/Untitled.png)

sudo vim /etc/default/grub

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/81104cd7-e97d-4d9e-9830-50811c7190f2/bff81373-e7bf-4228-91f0-18679dc1c430/Untitled.png)

nosmep, nokaslr, nopti 을 넣어주고 grub을 업데이트 하면 disable 할 수 있다.

bzImage 추출 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/81104cd7-e97d-4d9e-9830-50811c7190f2/ddc48413-ea7d-48d3-a735-ab6733f7df5c/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/af926a36-be4b-472c-83a7-63d782605250/Untitled.png)

추출해서 ROP gadget을 찾을 수 있다고 했는데 안된다. smep 이 켜져 있어서 그런것 같다. 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/81104cd7-e97d-4d9e-9830-50811c7190f2/e10094a3-3e65-4618-bd5f-7c9b189978cf/Untitled.png)

**<sever_run.sh>**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ef363f13-ce2e-40ed-8821-2e5fa145a0e2/Untitled.png)

위의 local_run.sh 와 비교했을 때 -s 옵션만 빠져있다. 

prepare_kernel_cred 와 commit_creds 함수는 보통 kernel exploit을 작성할 때 root 권한을 얻어오는 작업을 수행할 때 사용하는 함수. 

<prepare_kernel_cred>

prepare_kernel_cred() 함수를 통해 root권한의 자격증명 얻는 함수

<commit_creds>

이 함수는 프로세스의 신원을 변경시키는 함수.  <prepare_kernel_cred>에서 얻는 것을 이용해서 실제 권한상승(신원 바꾸기)을 할 수 있다. 

babykernel.ko 을 ida에 넣어보았다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f6d1afbc-fccc-4a2f-bd0c-d0fd34b9471b/Untitled.png)

여러 함수들이 있다.

<bk_ioctl>

```c
__int64 __fastcall bk_ioctl(__int64 a1, int a2)
{
  __int64 v2; // rdx
  _QWORD *v4; // rax
  char *v5; // rbx
  _QWORD *v6; // rsi

  _fentry__();
  copy_from_user(&user_input, v2, 24LL);
  switch ( a2 )
  {
    case 4098:
      v5 = (char *)&ops + 8 * *(&user_input + 2);
      v6 = (_QWORD *)kmem_cache_alloc_trace(kmalloc_caches[18], 6291648LL, 16LL);
      *v6 = v5;
      if ( (unsigned __int64)*(&user_input + 1) > 0x10 )
        _copy_overflow(16LL, *(&user_input + 1));
      else
        copy_to_user(user_input, v6);
      break;
    case 4099:
      ((void (*)(void))((char *)&ops + 8 * *(&user_input + 2)))();
      break;
    case 4097:
      v4 = (_QWORD *)kmem_cache_alloc_trace(kmalloc_caches[18], 6291648LL, 16LL);
      *v4 = &commit_creds;
      if ( (unsigned __int64)*(&user_input + 1) <= 0x10 )
        copy_to_user(user_input, v4);
      break;
  }
  return 1LL;
}
```

case 4098 일 경우: ‘ops’이라는 배열에서

case 4099 일 경우:

case 4097 일 경우:

<init_module>

```scala
__int64 __fastcall init_module()
{
  __int64 v0; // rbx
  __int64 v1; // rbp
  unsigned int v2; // ebx
  unsigned __int64 v3; // rdi
  unsigned int v5; // [rsp-1Ch] [rbp-1Ch] BYREF
  unsigned __int64 v6; // [rsp-18h] [rbp-18h]
  __int64 v7; // [rsp-10h] [rbp-10h]
  __int64 v8; // [rsp-8h] [rbp-8h]

  _fentry__();
  v8 = v1;
  v7 = v0;
  v6 = __readgsqword(0x28u);
  if ( (unsigned int)alloc_chrdev_region(&v5, 0LL, 1LL, "babykernel") )
  {
    v2 = -1;
  }
  else
  {
    v2 = 0;
    dword_D78 = v5 >> 20;
    v5 &= 0xFFF00000;
    cdev_init(&unk_DA0, &bk_fops);
    if ( (unsigned int)cdev_add(&unk_DA0, v5, 1LL) )
      unregister_chrdev_region(v5, 1LL);
    v3 = _class_create(&_this_module, "babykernel", &dword_D78);
    qword_D80 = v3;
    if ( v3 > 0xFFFFFFFFFFFFF000LL )
    {
      cdev_del(&unk_DA0);
      unregister_chrdev_region(v5, 1LL);
      v2 = -1;
    }
    else if ( !device_create(v3, 0LL, (unsigned int)(dword_D78 << 20), 0LL, "babykernel") )
    {
      class_destroy(qword_D80);
      cdev_del(&unk_DA0);
      unregister_chrdev_region(v5, 1LL);
    }
  }
  if ( v6 == __readgsqword(0x28u) )
    return v2;
  else
    return cleanup_module();
}
```

이 함수는 그냥 기본 모듈 함수인 것 같다. 

도움 받은 사이트

https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/
